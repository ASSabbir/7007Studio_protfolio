<!DOCTYPE html>
<html>
<head>
    <title>Gesture-Controlled 3D Particles (Three.js & Shaders)</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000;
        }
        canvas { 
            display: block; 
        }
        /* Optional: Container for the hidden webcam feed needed by MediaPipe */
        #webcam-container { 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            opacity: 0; 
            /* MediaPipe needs a visible element to render the video, 
               but we hide it as only the data matters */
        }
    </style>
</head>
<body>
    <div id="webcam-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float time;
        uniform float particleSize; 
        uniform float pinchStrength; // 0 to 1, for expansion/explosion
        uniform int templateIndex; 
        
        attribute vec3 positionOffset; 

        void main() {
            // 1. Particle Movement and Template Base Position
            vec3 animatedPosition = position + positionOffset;
            
            // Simple upward drift for all templates
            animatedPosition.y += mod(time * 0.1, 10.0); 

            // 2. Template-Specific Transformations
            if (templateIndex == 0) { // Default/Firework Template
                // No complex shaping, particles move randomly outwards
            }
            else if (templateIndex == 1) { // Heart Template (Conceptual shaping)
                // A complex function would be needed here to map the initial position
                // to a heart shape, which then pulses.
                // Example: animatedPosition.x *= (1.0 + sin(time) * 0.1);
            }
            else if (templateIndex == 2) { // Saturn Ring Template
                // Distribute particles in a ring shape over time
                float angle = atan(animatedPosition.y, animatedPosition.x);
                float radius = 2.0;
                animatedPosition.x = cos(angle + time * 0.5) * radius;
                animatedPosition.y = sin(angle + time * 0.5) * radius;
            } 
            
            // 3. Gesture-Controlled Expansion/Interaction
            // Particles explode outwards based on pinchStrength (low pinch = high expansion)
            vec3 direction = normalize(animatedPosition - vec3(0.0));
            // Invert pinchStrength effect: Strong pinch (1.0) keeps particles close.
            float expansionFactor = 2.0 * (1.0 - pinchStrength); 
            animatedPosition += direction * expansionFactor;

            // 4. Set Point Size
            gl_PointSize = particleSize * (1.0 + sin(time * 5.0) * 0.5); // Pulsing size
            
            // Scale size based on camera distance (Perspective correction)
            vec4 mvPosition = modelViewMatrix * vec4(animatedPosition, 1.0);
            gl_PointSize *= (300.0 / -mvPosition.z); 

            // Final Position
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform float handZDepth; // Controlled by hand Z-depth for color shift
        uniform int templateIndex;

        void main() {
            // 1. Particle Mask (Creates a smooth circular shape)
            vec2 coords = gl_PointCoord - vec2(0.5);
            float dist = length(coords);
            float alpha = 1.0 - smoothstep(0.4, 0.5, dist); 
            
            if (alpha < 0.01) discard; // Optimization: don't render invisible pixels

            // 2. Base Color Shifting based on Hand Depth
            vec3 baseColor = vec3(0.8, 0.2, 0.5); // Purple/Pink
            vec3 targetColor = vec3(0.2, 0.8, 0.8); // Cyan/Aqua
            
            // Interpolate color based on handZDepth (simulating depth movement)
            vec3 finalColor = mix(baseColor, targetColor, handZDepth);

            // 3. Template Color Overrides
            if (templateIndex == 0) { // Firework/Default: Time-based rainbow
                float hue = mod(time * 0.3, 1.0);
                finalColor = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), hue);
            }
            else if (templateIndex == 2) { // Saturn: Yellowish/Red hue
                 finalColor = vec3(1.0, 0.8, 0.2);
            }

            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <script>
        let scene, camera, renderer, particles;
        const NUM_PARTICLES = 50000; 

        // --- GESTURE SIMULATION VARIABLES ---
        // These variables would be updated by the MediaPipe Hand Tracking results
        let pinchStrength = 0.5; // Starts at halfway open. Use 0.0 for wide open, 1.0 for fully pinched.
        let handPosition = new THREE.Vector3(0, 0, 0); // Center of the hand (X, Y, Z)
        let particleTemplateIndex = 2; // Start on Saturn (0: Default/Firework, 2: Saturn)
        // ------------------------------------
        
        // --- INPUT SIMULATION (Press 1, 2, 3 to change templates) ---
        document.addEventListener('keydown', (event) => {
            if (event.key === '1') {
                particleTemplateIndex = 0; // Default/Firework
                console.log("Template switched to: Firework");
            } else if (event.key === '2') {
                particleTemplateIndex = 1; // Heart (Conceptual)
                console.log("Template switched to: Heart");
            } else if (event.key === '3') {
                particleTemplateIndex = 2; // Saturn Ring
                console.log("Template switched to: Saturn Ring");
            }
        });

        // --- MOUSE CONTROL SIMULATION (Control pinch/depth with mouse) ---
        document.addEventListener('mousemove', (event) => {
            // Map Mouse X (0 to window.innerWidth) to pinchStrength (0.0 to 1.0)
            pinchStrength = event.clientX / window.innerWidth;

            // Map Mouse Y (0 to window.innerHeight) to Hand Y position (3D space)
            handPosition.y = -(event.clientY / window.innerHeight) * 5 + 2.5; // map to -2.5 to 2.5

            // Simulating Z depth with time for color changes
            handPosition.z = (Math.sin(Date.now() * 0.001) + 1) / 2; // 0 to 1 range
        });
        
        // --- INITIALIZATION ---
        function initThree() {
            // Scene Setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Camera position
            camera.position.z = 8;
            
            // Create Particle Geometry
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const offsets = []; // Initial position offset attribute (used for shape structure)
            
            for (let i = 0; i < NUM_PARTICLES; i++) {
                // Initial random positions
                positions.push(THREE.MathUtils.randFloatSpread(5)); // X
                positions.push(THREE.MathUtils.randFloatSpread(5)); // Y
                positions.push(THREE.MathUtils.randFloatSpread(5)); // Z

                // Offsets for the shader to use
                offsets.push(THREE.MathUtils.randFloatSpread(10)); 
                offsets.push(THREE.MathUtils.randFloatSpread(10)); 
                offsets.push(THREE.MathUtils.randFloatSpread(10));
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('positionOffset', new THREE.Float32BufferAttribute(offsets, 3));
            
            // Shader Material Setup
            const uniforms = {
                time: { value: 0.0 },
                particleSize: { value: 20.0 },
                pinchStrength: { value: pinchStrength },
                handZDepth: { value: handPosition.z },
                templateIndex: { value: particleTemplateIndex },
            };
            
            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending, // Great for glowing particles
                depthTest: false 
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            
            // 1. Update Uniforms with live (or simulated) data
            const uniforms = particles.material.uniforms;
            uniforms.time.value += 0.01;
            
            // Pass gesture data
            uniforms.pinchStrength.value = pinchStrength;
            uniforms.handZDepth.value = handPosition.z; 
            uniforms.templateIndex.value = particleTemplateIndex; 

            // 2. Move Particle System
            // The position of the whole system is tracked to the simulated hand Y position
            particles.position.y = handPosition.y;

            renderer.render(scene, camera);
        }

        // Start the application
        initThree();
        animate();

        // ----------------------------------------------------------------------
        // *** To enable live camera control, you must implement the MediaPipe setup here ***
        // ----------------------------------------------------------------------
        /* function setupMediaPipe() {
            const videoElement = document.createElement('video');
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.onResults(onResults); // onResults updates pinchStrength, handPosition, etc.

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 1280,
                height: 720
            });
            camera.start();
        }

        // Placeholder for the MediaPipe results function
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                 // --- INSERT THE LANDMARK PROCESSING LOGIC HERE ---
                 // This is where you calculate:
                 // pinchStrength = f(distance(thumb, index))
                 // handPosition = f(landmarks)
            }
        }
        
        // Uncomment the line below to initialize the tracking logic
        // setupMediaPipe();
        */
        
    </script>
</body>
</html>